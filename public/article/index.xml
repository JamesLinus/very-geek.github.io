<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Articles on 太极客</title>
    <link>http://very-geek.github.io/article/</link>
    <description>Recent content in Articles on 太极客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Fri, 06 May 2016 13:03:20 +0800</lastBuildDate>
    <atom:link href="http://very-geek.github.io/article/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>JavaScript 程序员眼中的 Elixir：函数</title>
      <link>http://very-geek.github.io/article/elixir-for-javascript-programmer-part-03/</link>
      <pubDate>Fri, 06 May 2016 13:03:20 +0800</pubDate>
      
      <guid>http://very-geek.github.io/article/elixir-for-javascript-programmer-part-03/</guid>
      <description>

&lt;p&gt;这是一个 Elixir 的匿名函数以及执行它的方式：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;iex(1)&amp;gt; sum = fn a, b -&amp;gt; a + b end
#Function&amp;lt;12.50752066/2 in :erl_eval.expr/5&amp;gt;
iex(2)&amp;gt; sum.(1, 2)
3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在区别它和 JavaScript 的匿名函数之前，我更倾向于先理解函数的本质。因为差别之处只在于语法细节，而本质才有助于真正理解函数自身。&lt;/p&gt;

&lt;p&gt;如果你问我 JavaScript 的函数究竟是什么，我会说函数就是一个对象，下面几句代码在本质上是一样（箭头函数的特性不在本篇的讨论范围之内）的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const sum = (a, b) =&amp;gt; a + b
// or
const sum = function(a, b) {
  return a + b
}

// vs.

const sum = new Function(&#39;a&#39;, &#39;b&#39;, &#39;return a + b&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为函数就是 &lt;code&gt;Function&lt;/code&gt; 对象，所以每一个函数都拥有 &lt;code&gt;Function.prototype&lt;/code&gt; 的成员，诸如 &lt;code&gt;call&lt;/code&gt;，&lt;code&gt;apply&lt;/code&gt; 等等。&lt;/p&gt;

&lt;p&gt;那么对象又是什么？可以在 Elixir 中找到对应的东西吗？&lt;/p&gt;

&lt;p&gt;无论高级语言之间如何不同（比如 OO 范式与 FP 范式之间的差异），它们最终都会变成二进制的代码交由计算机来执行，所有的“数据”终究都是存储介质里的值。对象就是内存里的值，只不过它具有特定的且相对复杂的结构（相对于原始类型而言）；函数式语言不谈对象，但是它也有特定的复杂结构，所以本质上也会像对象一样最终表现为内存中的值。&lt;/p&gt;

&lt;p&gt;现在，对比一下这两句代码：&lt;code&gt;&amp;quot;Elixir is awesome&amp;quot;&lt;/code&gt; 和 &lt;code&gt;fn name -&amp;gt; &amp;quot;#{name} is awesome&amp;quot; end&lt;/code&gt;，你如何看待它们的异同？&lt;/p&gt;

&lt;p&gt;从某种抽象层次来说，它们没什么不同——都是内存里的值。可以这么说：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;我们用 &lt;code&gt;&amp;quot;&amp;quot;&lt;/code&gt; 来表示这是一个代表了字符串的值，其内容为 &lt;code&gt;Elixir is awesome&lt;/code&gt;；因为英文字母和单词可以在语言里表示很多种意思，为了让解释器知道这是字符串而不是别的什么所以才用 &lt;code&gt;&amp;quot;&amp;quot;&lt;/code&gt; 来表示，于是 Elixir 知道如何用正确的底层代码来表示它。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;类似的，我们用 &lt;code&gt;fn...end&lt;/code&gt; 来表示这是一个匿名函数，其内容是 &lt;code&gt;parameter-list -&amp;gt; function body&lt;/code&gt;，这个内容比字符串复杂一些，它用 &lt;code&gt;-&amp;gt;&lt;/code&gt; 分割成两个部分：左边是&lt;strong&gt;参数列表&lt;/strong&gt;，右边是&lt;strong&gt;函数体&lt;/strong&gt;。我们不用关心在底层是用什么方式来表示这些概念的，但是终究它们还是值而已。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;现在我可以很有信心的去学习函数在 Elixir 中的各种细节了，因为在本质上我已经在大脑中建立了一种映射模型，任何复杂一些的、会绕弯的细节我都可以对照其在 JavaScript 中的相同之处；如果有任何地方是用 JavaScript 的函数所无法解释的，我就会提高映射的抽象层次去设想它（们）的本质究竟为何——这是非常适合我的学习方式。&lt;/p&gt;

&lt;p&gt;好，因为函数就是值，所以我们可以把函数作为值传递给其他的函数，也可以作为值从其他的函数中返回，当然也可以执行它并为它传值（因为这个值有接收参数列表的内容构造）。这话听着耳熟吧？当我们谈及 “JavaScript 中的函数是一等公民”时，说的就是这些事情。唯一的区别就在于 Elixir 的函数不是对象（因为我们在函数式语言里没有对象这一层抽象），但终究和对象一样也是值而已。&lt;/p&gt;

&lt;h2 id=&#34;函数和模式匹配:9a3f0e45bc161da5e8e8c12625d36160&#34;&gt;函数和模式匹配&lt;/h2&gt;

&lt;p&gt;还是看这个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;iex(1)&amp;gt; sum = fn a, b -&amp;gt; a + b end
#Function&amp;lt;12.50752066/2 in :erl_eval.expr/5&amp;gt;
iex(2)&amp;gt; sum.(1, 2)
3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当我们调用该函数并传参时，很容易会想成：“传实参 &lt;code&gt;1&lt;/code&gt; 和 &lt;code&gt;2&lt;/code&gt; 进去，&lt;strong&gt;赋值&lt;/strong&gt;给形参 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt;”……哦，等等！看到赋值俩字吗？这是一个“危险”的信号。&lt;/p&gt;

&lt;p&gt;在 JavaScript 中，形式参数等于本地变量的名字，实际参数等于本地变量的值。当函数被调用时，的确在函数体内有隐式的赋值行为。但是在 Elixir 中并不是这样的，永远没有赋值！上面的行为类似于 &lt;code&gt;{a, b} = {1, 2}&lt;/code&gt; 这样的模式匹配。&lt;/p&gt;

&lt;p&gt;这有啥不同呢？不同之处就在于我们可以做这种事情：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;iex(1)&amp;gt; swap = fn {x, y} -&amp;gt; {y, x} end
#Function&amp;lt;6.50752066/1 in :erl_eval.expr/5&amp;gt;
iex(2)&amp;gt; swap.({0, 1})
{1, 0}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然 JavaScript 有了解构之后也可以做类似的事情：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const swap = ([x, y]) =&amp;gt; [y, x]
swap([0, 1])
// =&amp;gt; [1, 0]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不过&lt;a href=&#34;http://very-geek.github.io/article/elixir-for-javascript-programmer-part-01&#34;&gt;解构与模式匹配如何不同已经在前文里讲过&lt;/a&gt;，所以 JavaScript 在这方面并不能比肩于 Elixir。&lt;/p&gt;

&lt;h2 id=&#34;一个函数-多个函数体:9a3f0e45bc161da5e8e8c12625d36160&#34;&gt;一个函数，多个函数体&lt;/h2&gt;

&lt;p&gt;下面是在 Node.js 中（异步）读取一个本地文件内容的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;fs.readFile(&#39;config.toml&#39;, (err, data) =&amp;gt; {
  if err throw err
  console.log(data)
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;指定文件能否正确读取是无法提前确定的，因此回调函数会将 &lt;code&gt;err&lt;/code&gt; 作为第一个参数传进来，于是我们需要先看看有没有错误，有的话就要优先处理它，没有的话才能“自信的”处理实际的文件内容。这种“错误优先”的回调函数是 Node.js 的主流风格，本质上就是一种“事前约定”的分支处理模式。&lt;/p&gt;

&lt;p&gt;在 Elixir 中，类似的处理会更倾向于使用模式匹配来做，并且能带给我们非常独特的“一个函数，多个函数体”的语法风格：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;read_file = fn
  {:ok, data} -&amp;gt; &amp;quot;Read data as: #{IO.read(data, :line)}&amp;quot;
  {_, error} -&amp;gt; &amp;quot;Error as: #{:file.format_error(error)}&amp;quot;
end

read_file.(File.open(&amp;quot;config.toml&amp;quot;))
# &amp;quot;Read data as: baseurl = \&amp;quot;http://very-geek.github.io/\&amp;quot;\n&amp;quot;

# or

read_file.(File.open(&amp;quot;config.yaml&amp;quot;))
# &amp;quot;Error as: no such file or directory&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我觉得这种风格非常有趣且实用：我们不去判断有没有错误而是直接模式匹配入参，匹配成功就会执行对应的函数体。我们曾经说过 Elixir 的世界里函数的行为都遵循着一些“约定”，特别是用元组来做返回值这个约定尤其典型。在这种风格里无所谓是“错误优先”还是“正确优先”，每次执行都会匹配到唯一的结果，不需要判断或者提前处理，代码变得更容易读写和理解，执行的效率也更高了。&lt;/p&gt;

&lt;h3 id=&#34;继承-erlang-的丰饶-财产:9a3f0e45bc161da5e8e8c12625d36160&#34;&gt;继承 Erlang 的丰饶“财产”&lt;/h3&gt;

&lt;p&gt;在上例中我们使用了 &lt;code&gt;File.open/2&lt;/code&gt;，也使用了 &lt;code&gt;:file.format_error/1&lt;/code&gt;，这两者之间有什么区别呢？&lt;code&gt;File&lt;/code&gt; 是 Elixir 的模块，而 &lt;code&gt;:file&lt;/code&gt; 是 Erlang 的 &lt;code&gt;File&lt;/code&gt; 模块，也就是说因为 Elixir 构建于 Erlang VM 之上，所以我们可以直接访问底层虚拟机所提供的 APIs，Elixir 缺省使用同名小写的原子来代表 Erlang 里的同名模块。&lt;/p&gt;

&lt;h3 id=&#34;留心多个函数体的匹配顺序:9a3f0e45bc161da5e8e8c12625d36160&#34;&gt;留心多个函数体的匹配顺序&lt;/h3&gt;

&lt;p&gt;下面是我做的第一个 Elixir 的练习，经典的 “FuzzBuzz” 程序：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;fizz_buzz = fn
  {0, 0, _} -&amp;gt; IO.puts &amp;quot;FizzBuzz.&amp;quot;
  {0, _, _} -&amp;gt; IO.puts &amp;quot;Fizz.&amp;quot;
  {_, 0, _} -&amp;gt; IO.puts &amp;quot;Buzz.&amp;quot;
  {_, _, n} -&amp;gt; IO.puts n
end

take_number = fn
  n -&amp;gt; fizz_buzz.({rem(n, 3), rem(n, 5), n})
end

Enum.each 10..16, fn n -&amp;gt; take_number.(n) end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个程序很“纯真”😹 ，但是这里面有一个特别容易被初学者踩的坑。如果我们调换一下多个函数体的顺序：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;fizz_buzz = fn
  {0, _, _} -&amp;gt; IO.puts &amp;quot;Fizz.&amp;quot;
  {0, 0, _} -&amp;gt; IO.puts &amp;quot;FizzBuzz.&amp;quot;
  {_, 0, _} -&amp;gt; IO.puts &amp;quot;Buzz.&amp;quot;
  {_, _, n} -&amp;gt; IO.puts n
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行的结果就完全错误了。很显然如果两个待匹配且有多个值的模式在匹配时是“谁先匹配谁胜出”的，所以一定要小心这种情况。当然了，这种解法其实并不是最好的选择，以后我们再谈更合适的写法，所以这种问题是可以从根本上避免的。&lt;/p&gt;

&lt;h2 id=&#34;捕获操作符-capture-operator:9a3f0e45bc161da5e8e8c12625d36160&#34;&gt;捕获操作符（Capture Operator，&lt;code&gt;&amp;amp;&lt;/code&gt;）&lt;/h2&gt;

&lt;p&gt;Elixir 使用一个宏 &lt;code&gt;&amp;amp;&lt;/code&gt; 来简化匿名函数的创建与使用，这个特性在最初会让人晕乎乎一阵子，不过一旦建立起了坚实的思维模型就不难理解了。&lt;/p&gt;

&lt;p&gt;捕获操作符实际上有两种（非常相似的）用法，第一种就是捕获一个既存的函数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;iex(1)&amp;gt; nil? = &amp;amp;Kernel.is_nil/1
#Function&amp;lt;6.50752066/1 in :erl_eval.expr/5&amp;gt;
iex(2)&amp;gt; nil?.(nil)
true
iex(4)&amp;gt; nil?.(&amp;quot;nil&amp;quot;)
false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于捕获后的结果是一个匿名函数，所以调用的时候要留意调用时的语法。&lt;/p&gt;

&lt;p&gt;JavaScript 没有捕获操作符，上面的例子要用 JavaScript 来类比的话是这样的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const isArray = target =&amp;gt; Array.isArray(target)
isArray([]) // =&amp;gt; true
isArray(&amp;quot;&amp;quot;) // =&amp;gt; false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另外一种用法实际上就是创建匿名函数，主要用于函数的局部应用（Partially Apply）；此时 &lt;code&gt;&amp;amp;1&lt;/code&gt;，&lt;code&gt;&amp;amp;2&lt;/code&gt;, &amp;hellip;, &lt;code&gt;&amp;amp;n&lt;/code&gt; 用来做参数的占位符：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;# 以下是类似 JavaScript Array.prototype.map 的用法
Enum.map [1, 2, 3], &amp;amp;(&amp;amp;1 * &amp;amp;1)
# [1, 4, 9]

# 如果觉得脑袋转不过弯来，那么以下是等价的写法
Enum.map [1, 2, 3], fn n -&amp;gt; n * n end
# [1, 4, 9]

# 或者可以写得更明确（以及具备可复用性）些：
square = &amp;amp;(&amp;amp;1 * &amp;amp;1)
Enum.map [1, 2, 3], square
# [1, 4, 9]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以呢，&lt;code&gt;&amp;amp;(&amp;amp;1 * &amp;amp;1)&lt;/code&gt; 就等于 &lt;code&gt;fn n -&amp;gt; n * n end&lt;/code&gt; 而已，这种转换多玩几次就利索了。再看一个高阶函数的例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;double = &amp;amp;(&amp;amp;1 * 2)
apply = &amp;amp;(&amp;amp;1.(&amp;amp;2))
apply.(double, 3)
# 6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;简直 Amazing 了～，等价的匿名函数写法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;double = fn n -&amp;gt; n * 2 end
apply = fn (func, value) -&amp;gt; func.(value) end
apply.(double, 3)
# 6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;等价的 JavaScript 写法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const double = n =&amp;gt; n * 2
const apply = (func, value) =&amp;gt; func(value)
apply(double, 3)
// =&amp;gt; 6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我一遍遍的重复是因为在实战中捕获操作符用得很多，所以尽早的把它变成一种“本能”会让你后续的学习变得更加平顺。&lt;/p&gt;

&lt;h2 id=&#34;模块与具名函数:9a3f0e45bc161da5e8e8c12625d36160&#34;&gt;模块与具名函数&lt;/h2&gt;

&lt;p&gt;我们一直在说匿名函数，具名函数又如何呢？和 JavaScript 一样，函数在 Elixir 中也有具名与匿名之分，但是具名函数在 Elixir 中不能随处定义，它们只能定义在模块（Module）之中。&lt;/p&gt;

&lt;p&gt;当代码的规模开始增长，我们就需要更好的组织代码方式。OO 语言有封装的概念，不管是基于类（Class）还是基于原型（Prototype），本质上都还是组织代码的形式。只不过封装这个概念具有包裹和控制“状态”的意图在里面，而 Elixir 的模块相对单纯一些，因为不可变数据的特点决定了没有状态管理这么回事儿。&lt;/p&gt;

&lt;p&gt;具名函数在模块之中扮演了“代码逻辑分割者”的角色，最基本的例子如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;defmodule Calculator do
  def sum(a, b) do
    a + b
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;和 Ruby 简直太像了不是么？&lt;/p&gt;

&lt;p&gt;模块扮演的是“命名空间”的角色，上面的例子我们可以用 &lt;code&gt;Calculator.sum/2&lt;/code&gt; 的签名形式来代表，后面的 &lt;code&gt;/2&lt;/code&gt; 指的是 &lt;code&gt;Calculator.sum&lt;/code&gt; 函数接收的参数个数。 在 Elixir 中，具名函数的标识由两部分组成：函数名及参数数量。这一特性决定了 Elixir 允许在模块中定义同名的函数，只要参数数量不等就可以。所以我们可以这样写：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;defmodule Calculator do
  def sum(a) do
    a + 1
  end

  def sum(a, b) do
    a + b
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 Elixir 的眼中上面两个 &lt;code&gt;sum&lt;/code&gt; 是完全不同的具名函数，然而在人类的眼中因为函数名称相同，于是它们之间似乎表达着某种关联性。这是 OK 的，符合自然语言的习惯，只不过我们需要注意别让两个同名函数做“风马牛不相及”的事情——这是人的责任而不是机器的。&lt;/p&gt;

&lt;h3 id=&#34;函数体与作用域:9a3f0e45bc161da5e8e8c12625d36160&#34;&gt;函数体与作用域&lt;/h3&gt;

&lt;p&gt;和 JavaScript 相同，Elixir 最小的的作用域范围也是函数级别的。我们可以把 &lt;code&gt;do...end&lt;/code&gt; 看作是作用域分隔的标示符，但要注意的是 &lt;code&gt;do...end&lt;/code&gt; 不是底层的语法，它是一个语法糖，最终在编译的时候会被解释成 &lt;code&gt;do:&lt;/code&gt;。也就是说，函数也可以写作：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;def sum(a, b), do: a + b  # 注意逗号！
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以用这种“内联”的形式来定义函数，只需要在脑海中明确这种语法糖的转换关系。我们甚至连模块定义都能内联（但为了代码的可读性起见，最好别这么做）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;defmodule Calculator, do: (def sum(a, b), do: a + b)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此外，&lt;code&gt;do...end&lt;/code&gt; 所构造的代码块并非只能用作具名函数定义，它也被用作其他的一些控制结构中，我们以后会看到更多的例子。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;do...end&lt;/code&gt; 有一个容易让初学者挠头的陷阱，要牢记：&lt;code&gt;do...end&lt;/code&gt; 代码块总是绑定在最外层的函数调用上，所以必要的时候要使用 &lt;code&gt;()&lt;/code&gt; 分隔表达式的优先层级。具体的例子可以看&lt;a href=&#34;http://elixir-lang.org/getting-started/case-cond-and-if.html#doend-blocks&#34;&gt;官方的范例&lt;/a&gt;（在最末尾处）。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;除了最基本的函数作用域之外模块也会定义新的作用域，但是这个作用域不会“穿透”至其下的函数作用域内。也就是说，定义于模块作用域内的本地变量是无法在函数体内访问的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;defmodule Calculator do
  factor = 1

  def sum(a) do
    a + factor
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上述代码是错误的，无法通过编译，Elixir 会认为 &lt;code&gt;sum/1&lt;/code&gt; 里的 &lt;code&gt;factor&lt;/code&gt; 是没有定义的函数，同时会警告 &lt;code&gt;Calculator&lt;/code&gt; 里定义的 &lt;code&gt;factor&lt;/code&gt; 是未使用的变量。于是我们可以想到定义一个 &lt;code&gt;factor/0&lt;/code&gt; 来单纯返回一个值，这是可以的；不过模块可以定义一种特殊的“模块属性（Module Attribute）”来提供可访问的值：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;defmodule Calculator do
  @factor 1

  def sum(a) do
    a + @factor
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;函数体内不能定义模块属性，因为本质上模块属性并非变量，从 OO 语言的角度来看倒是可以理解为模块级别的“常量”。模块属性可以重复定义（所以也不能等同于常量），函数在访问模块属性的时候总是向上寻找离自己最近的模块属性定义所对应的值。&lt;/p&gt;

&lt;h3 id=&#34;私有函数:9a3f0e45bc161da5e8e8c12625d36160&#34;&gt;私有函数&lt;/h3&gt;

&lt;p&gt;模块内部可以使用 &lt;code&gt;defp&lt;/code&gt; 定义私有函数，私有函数只能在所定义的模块内部访问，其他的特性和一般的具名函数没有差别。&lt;/p&gt;

&lt;p&gt;但是当你定义了多个同名函数（参数个数不同）时，它们要么都是私有的要么都不是，不能两种函数混合定义。&lt;/p&gt;

&lt;h3 id=&#34;参数默认值:9a3f0e45bc161da5e8e8c12625d36160&#34;&gt;参数默认值&lt;/h3&gt;

&lt;p&gt;函数定义的参数可以有默认值，不过语法很古怪：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;def sum(a, b // 1) do
  a + b
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们已经知道 Elixir 不存在“赋值”一说，所以默认值不用 &lt;code&gt;=&lt;/code&gt; 也就不难理解了。&lt;/p&gt;

&lt;p&gt;如果一个函数有多个定义且需要给参数默认值，那就需要先写一个空的函数头声明（也就是没有实际函数体的声明），然后再写剩下的定义：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;defmodule Concat do
  def join(a, b \\ nil, sep \\ &amp;quot; &amp;quot;)

  def join(a, b, _sep) when is_nil(b) do
    a
  end

  def join(a, b, sep) do
    a &amp;lt;&amp;gt; sep &amp;lt;&amp;gt; b
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;守护语句-guard-clause:9a3f0e45bc161da5e8e8c12625d36160&#34;&gt;守护语句（Guard Clause）&lt;/h3&gt;

&lt;p&gt;守护语句的概念在 JavaScript（及其他高级语言）中也是有的，我们经常在函数中使用守护性的预先判断来提前返回或中断函数的执行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function rename(oldName, newName) {
  if (!oldName) return false // or throw errors if needed
  if (!newname) throw &#39;You need to provide a new name!&#39;
  oldName = newName
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;概念是很简单的，不过在 Elixir 中的写法很不同了，Elixir 在语法层面直接提供了守护语句的写法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;defmodule TellMe do
  def what_is(x) when is_atom(x) do
    IO.puts &amp;quot;#{x} is an atom&amp;quot;
  end

  def what_is(x) when is_number(x) do
    IO.puts &amp;quot;#{x} is a number&amp;quot;
  end

  def what_is(x) when is_list(x) do
    IO.puts &amp;quot;#{x} is a list&amp;quot;
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面这段代码纯属演示性质，实际意义不大，不过我们可以看到守护语句填补了模式匹配的一些“空白”，这一点是很有意义的。&lt;/p&gt;

&lt;h3 id=&#34;模式匹配-守护语句:9a3f0e45bc161da5e8e8c12625d36160&#34;&gt;模式匹配＋守护语句&lt;/h3&gt;

&lt;p&gt;这两者的搭配是 Elixir 语言中很精彩的且具有代表性的应用技巧。模式匹配能满足结构和值相等性的比较并能为变量进行必要的值绑定，但是如果你要针对值做一些额外的比较——比如说类型检测或是转换测试之类的，就需要守护语句来协助了。&lt;/p&gt;

&lt;p&gt;一个很经典的例子是递归阶乘在 Elixir 里的实现：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;defmodule Factorial do
  def of(0), do: 1
  def of(n), do: n * of(n - 1)
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;简单、优雅，但是不完善——如果我们传入的 &lt;code&gt;n&lt;/code&gt; 是负数会怎样呢？（无限循环，因为第一个 &lt;code&gt;of/1&lt;/code&gt; 永远也匹配不到）&lt;/p&gt;

&lt;p&gt;如果我们不关心处理负数的情况，那就可以简单的加上守护语句：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;defmodule Factorial do
  def of(0), do: 1
  def of(n) when n &amp;gt; 0, do: n * of(n - 1)
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在如果你传入负数的话，Elixir 会抛出错误告诉你没有能够处理此类参数的 &lt;code&gt;Factorial.of/1&lt;/code&gt;，这正好符合我们的需要。&lt;/p&gt;

&lt;p&gt;在默认环境下，守护语句并不是万能的，&lt;a href=&#34;http://elixir-lang.org/getting-started/case-cond-and-if.html#expressions-in-guard-clauses&#34;&gt;Elixir 只提供了一些缺省的表达式供其使用&lt;/a&gt;。不过守护语句可用的表达式是可以扩展的，这算是一个高级话题，我们留待后谈。&lt;/p&gt;

&lt;p&gt;我认为前面所介绍的内容已经涵盖了 Elixir 函数的基本特性，有了这些知识就足以进一步探索 Elixir 的世界了。但是和函数相关的还有一个非常非常重要的特性管道操作符还没有涉及，管道操作符是 Elixir 令人着迷的特色之一，但是谈它之前有必要先讲枚举（Enumerable）和流（Stream），函数在其中扮演的是“穿针引线”的角色。因此，本篇告一段落，下一篇我们先从列表和递归讲起，开始真正触及函数式编程的核心之处。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JavaScript 程序员眼中的 Elixir：集合</title>
      <link>http://very-geek.github.io/article/elixir-for-javascript-programmer-part-02/</link>
      <pubDate>Thu, 05 May 2016 00:00:00 +0800</pubDate>
      
      <guid>http://very-geek.github.io/article/elixir-for-javascript-programmer-part-02/</guid>
      <description>

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;iex(1)&amp;gt; [1, :foo, 3.14, &amp;quot;bar&amp;quot;, {1, 2, 3}]
[1, :foo, 3.14, &amp;quot;bar&amp;quot;, {1, 2, 3}]

iex(2)&amp;gt; {1, :foo, 3.14, &amp;quot;bar&amp;quot;, [1, 2, 3]}
{1, :foo, 3.14, &amp;quot;bar&amp;quot;, [1, 2, 3]}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;请问看过上述代码之后是何感想？我第一次看呢感觉就是：晕～&lt;/p&gt;

&lt;p&gt;那换个问题，上面两种集合哪个接近 JavaScript 里的数组（Array）？从符号上看应该是第一种：列表（List），可实际上最接近的是第二种：元组（Tuple），但是在 Elixir 中我们却不太会用在 JavaScript 中使用数组那样去使用元组。&lt;/p&gt;

&lt;h2 id=&#34;元组-tuple:09efefb5582c071e5bc0e8d88fb3cabd&#34;&gt;元组（Tuple）&lt;/h2&gt;

&lt;p&gt;元组是有序的数值集合，并且它是在内存中连续存储这些数值的，这就意味着通过下标（也是从 0 开始）访问数值以及获得元组的长度这样的操作是很快的。&lt;/p&gt;

&lt;p&gt;典型的 Elixir 程序里一般不太会用元组来表示大量数据集合，有三五个就了不起啦～当需要表示更多的数据的时候会倾向于选择其它的集合类型——JavaScript 里那是没得挑，要么就自己去实现好了。原因？在我看来可能是因为元组并没有实现 &lt;code&gt;Enumerable&lt;/code&gt; 协议的缘故，这个不急我们后面会讲。&lt;/p&gt;

&lt;p&gt;Elixir 用于操作元组的函数并不多，翻翻 API 文档也就十分钟全部看完，不过有几个方法是在 &lt;code&gt;Kernel&lt;/code&gt; 模块里的，要注意别漏了。它们分别是：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Kernel.elem/2&lt;/code&gt;，&lt;code&gt;Kernel.is_tuple/1&lt;/code&gt;，&lt;code&gt;Kernel.put_elem/3&lt;/code&gt;，以及 &lt;code&gt;Kernel.tuple_size/1&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;Elixir 中有一个非常重要的“习俗”：让函数返回元组，且当没有错误的时候，元组的第一个值是原子 &lt;code&gt;:ok&lt;/code&gt;，这个习惯特别像 Node.js 的 error first callback，但在 Elixir 配合模式匹配则更加普遍和强大。下面就是一个常见的例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;iex(1)&amp;gt; File.open(&amp;quot;config.toml&amp;quot;)
{:ok, #PID&amp;lt;0.60.0&amp;gt;}
iex(2)&amp;gt; File.open(&amp;quot;config.yaml&amp;quot;)
{:error, :enoent}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关于这个以后还要深入地说，现在还是把焦点集中在集合上面吧。&lt;/p&gt;

&lt;h2 id=&#34;列表-list:09efefb5582c071e5bc0e8d88fb3cabd&#34;&gt;列表（List）&lt;/h2&gt;

&lt;p&gt;由于写法完全一致所以列表太容易被看作是 JavaScript 数组了，可是相比元组来说列表与数组的差异就更大了。&lt;/p&gt;

&lt;p&gt;首先列表是链表集合而不是线性表集合，列表要么就是空的，要么就是由头（head）和尾（tail）组成：头保存一个值，尾本身又是一个列表。这是一种递归式的结构定义，而它正是大多数 Elixir 程序的核心。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;JavaScript 的数组是线性表集合吗？JavaScript 是动态语言，这意味着数组的存储方式也是可以动态规划的。事实上，不同的引擎对此会有不同的处理方式，因此很难一概而论。大体上我们认为 JavaScript 数组是线性的，因而也会有很多文章教程来探讨在 JavaScript 中创建自己的链表数据结构。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这种结构使得列表利于遍历但不利于随机读取（比如获取列表中第 &lt;em&gt;n&lt;/em&gt; 个元素总是要先扫描前面的 &lt;em&gt;n-1&lt;/em&gt; 个元素）。不过获取列表的头然后提取列表的尾则总是高效的。&lt;/p&gt;

&lt;p&gt;列表有一种特性最值得牢记：对于不可变数据结构来说，想要修改它就意味着要先复制一份新的；然而由于列表是头尾结合的递归结构，要想去掉列表的头就不需要复制列表本身，只需要返回列表尾的指针就可以了。这种特性被广泛应用在列表的遍历与递归操作中。&lt;/p&gt;

&lt;p&gt;列表支持下面的操作符（实际上都是 &lt;code&gt;Kernel&lt;/code&gt; 模块下的函数／宏）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;iex(1)&amp;gt; [1, 2, 3] ++ [4, 5, 6]
[1, 2, 3, 4, 5, 6]
iex(2)&amp;gt; [1, 1, 2, 3, 3, 4] -- [2, 3, 4]
[1, 1, 3]
iex(3)&amp;gt; 1 in [1, 2, 3]
true
iex(4)&amp;gt; 0 in [1, 2, 3]
false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;列表模块里的函数也比元组要多得多，不过在实践中建议优先选择 &lt;code&gt;Enum&lt;/code&gt; 模块下的函数来操作列表。另外 &lt;code&gt;Kernel.hd/1&lt;/code&gt; 与 &lt;code&gt;Kernel.tl/1&lt;/code&gt; 分别用来取列表的头和尾。&lt;/p&gt;

&lt;p&gt;下面是一个有趣的特性叫做字符列表（Char List），目前仅作了解即可。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;iex(1)&amp;gt; [104, 101, 108, 108, 111]
&#39;hello&#39;
iex(2)&amp;gt; &#39;hello&#39; == &amp;quot;hello&amp;quot;
false
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;关键字列表-keyword-list:09efefb5582c071e5bc0e8d88fb3cabd&#34;&gt;关键字列表（Keyword List）&lt;/h2&gt;

&lt;p&gt;虽然名字里还有列表二字，但关键字列表却像 JavaScript 对象字面量那样是键值对形式的数据集合。既然如此为啥还非要算作列表呢？看：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;iex(1)&amp;gt; [name: &amp;quot;nightire&amp;quot;, age: 35] = [{:name, &amp;quot;nightire&amp;quot;}, {:age, 35}]
[name: &amp;quot;nightire&amp;quot;, age: 35]
iex(2)&amp;gt; [name: &amp;quot;nightire&amp;quot;, age: 35] == [{:name, &amp;quot;nightire&amp;quot;}, {:age, 35}]
true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;原来关键字列表就是一个二元元组的列表，每一个元组的第一个元素必须是原子（Atom），第二个元素可以是其它任何值，以此来代表一对关联数据结构。&lt;/p&gt;

&lt;p&gt;关键字列表的重要性源自于它自身的三大特点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;键必须是原子&lt;/li&gt;
&lt;li&gt;键是有序的，遵照定义时的顺序&lt;/li&gt;
&lt;li&gt;键可以给定多次&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面是一些例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;iex(1)&amp;gt; person = [name: &amp;quot;nightire&amp;quot;, age: 35]
[name: &amp;quot;nightire&amp;quot;, age: 35]
iex(2)&amp;gt; person[:name]
&amp;quot;nightire&amp;quot;
iex(3)&amp;gt; person[:age]
35

iex(4)&amp;gt; nightire = person ++ [likes: [&amp;quot;music&amp;quot;, &amp;quot;programming&amp;quot;]]
[name: &amp;quot;nightire&amp;quot;, age: 35, likes: [&amp;quot;music&amp;quot;, &amp;quot;programming&amp;quot;]]
iex(5)&amp;gt; nightire[:likes]
[&amp;quot;music&amp;quot;, &amp;quot;programming&amp;quot;]

iex(6)&amp;gt; younger = [age: 18] ++ nightire
[age: 18, name: &amp;quot;nightire&amp;quot;, age: 35, likes: [&amp;quot;music&amp;quot;, &amp;quot;programming&amp;quot;]]
iex(7)&amp;gt; younger[:age]
18
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关键字列表特别适合用作函数传参或者是用作构造 DSL，比如说：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;query = from p in People,
   where: p.age &amp;gt; 18,
   where: p.weight &amp;lt; 100
  select: p
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以及：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;DB.save record, name: &amp;quot;nightire&amp;quot;, admin: true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个例子同时也告诉我们 Elixir 允许在关键字列表作为函数调用的最后一个参数时省略 &lt;code&gt;[]&lt;/code&gt;。省略环绕标记这件事情有时候会让人晕一下下，特别是要小心下面这种情形：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;iex(1)&amp;gt; [1, 2, foo: &amp;quot;bar&amp;quot;]
[1, 2, {:foo, &amp;quot;bar&amp;quot;}]
iex(2)&amp;gt; {1, 2, foo: &amp;quot;bar&amp;quot;}
{1, 2, [foo: &amp;quot;bar&amp;quot;]}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;除了作为函数参数列表的末尾项之外，作为元组及列表的末尾项也能省略环绕符号，这样的语法特性能省却很多字符但同时也会增加头脑中抽象解释和转换的负担。&lt;/p&gt;

&lt;p&gt;为了操作关键字列表 Elixir 专门提供了 &lt;code&gt;Keyword&lt;/code&gt; 模块，底下的函数也不少。以前关键字列表是实现了 &lt;code&gt;Dict&lt;/code&gt; 模块的，后来 &lt;code&gt;Dict&lt;/code&gt; 被废弃了，以后还是专用 &lt;code&gt;Keyword&lt;/code&gt; 好。&lt;/p&gt;

&lt;h2 id=&#34;映射-map:09efefb5582c071e5bc0e8d88fb3cabd&#34;&gt;映射（Map）&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;我看到一些中文资料把作为数据结构的 &lt;code&gt;Map&lt;/code&gt; 称作图，这是不对的。数据结构中的图应该是 &lt;code&gt;Graph&lt;/code&gt;，而 &lt;code&gt;Map&lt;/code&gt; 虽然有地图的意思但却和数据结构所说的“图”大不相同。&lt;code&gt;Map&lt;/code&gt; 同时也有映射的意思，其实指的就是一一对应的键／值对，在这里的含义非常准确。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;JavaScript 中的对象兼具关键字列表和映射的特性，实际上关键字列表所具备的特性使得它并不适合作为纯数据载体，而映射则特别适合。我猜想这也是为什么 ES2015 会添加 &lt;code&gt;Map&lt;/code&gt; 来替代一部分原属于 &lt;code&gt;Object&lt;/code&gt; 的职责。&lt;/p&gt;

&lt;p&gt;什么意思呢？首先，关键字列表的键只能是原子，相对的 JavaScript 对象的键名只能是字符串（其实还有符号类型，但是属于新数据类型，流传度不高），这就不够灵活了对吧。映射则没有这种限制，任何值都可以做映射中的键和值——包括复合类型；而且还能是表达式。另外如果映射中的键名全部是原子则可以使用关键字列表的语法来定义以提高便利性。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;iex(1)&amp;gt; %{0 =&amp;gt; 0, &amp;quot;one&amp;quot; =&amp;gt; 1, :two =&amp;gt; 2, [1, 2, 3] =&amp;gt; 3}
%{0 =&amp;gt; 0, :two =&amp;gt; 2, [1, 2, 3] =&amp;gt; 3, &amp;quot;one&amp;quot; =&amp;gt; 1}

iex(2)&amp;gt; %{one: 1, two: 2}
%{one: 1, two: 2}
iex(3)&amp;gt; %{one: 1, two: 2} == %{:one =&amp;gt; 1, :two =&amp;gt; 2}
true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其次，映射里的数据是不关心顺序的，而且键也不能重复，如果有重复的键添加进来则会覆盖之前的同名键值对。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;iex(1)&amp;gt; %{one: 1, one: &amp;quot;1&amp;quot;}
%{one: &amp;quot;1&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这一特性使得映射在模式匹配时比关键字列表有用（特别是键名唯一性），看看这些例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;iex(1)&amp;gt; %{} = %{:foo =&amp;gt; &amp;quot;foo&amp;quot;, &amp;quot;bar&amp;quot; =&amp;gt; :bar}
%{:foo =&amp;gt; &amp;quot;foo&amp;quot;, &amp;quot;bar&amp;quot; =&amp;gt; :bar}

iex(2)&amp;gt; %{:foo =&amp;gt; str} = %{:foo =&amp;gt; &amp;quot;foo&amp;quot;, &amp;quot;bar&amp;quot; =&amp;gt; :bar}
%{:foo =&amp;gt; &amp;quot;foo&amp;quot;, &amp;quot;bar&amp;quot; =&amp;gt; :bar}
iex(3)&amp;gt; str
&amp;quot;foo&amp;quot;

iex(4)&amp;gt; %{:baz =&amp;gt; any} = %{:foo =&amp;gt; &amp;quot;foo&amp;quot;, &amp;quot;bar&amp;quot; =&amp;gt; :bar}
** (MatchError) no match of right hand side value: %{:foo =&amp;gt; &amp;quot;foo&amp;quot;, &amp;quot;bar&amp;quot; =&amp;gt; :bar}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;做这种事情的时候是没法依靠关键字列表的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;iex(1)&amp;gt; [foo: str] = [foo: &amp;quot;foo&amp;quot;, bar: &amp;quot;bar&amp;quot;]
** (MatchError) no match of right hand side value: [foo: &amp;quot;foo&amp;quot;, bar: &amp;quot;bar&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 Elixir 中，会经常这样使用映射：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;response_types = %{
  {:error, :enoent} =&amp;gt; :fatal,
  {:error, :busy} =&amp;gt; :retry
}
# %{{:error, :busy} =&amp;gt; :retry, {:error, :enoent} =&amp;gt; :fatal}

response_types[{:error, :busy}]
# :retry
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而在 JavaScript 中如果只考虑对象的话这是不可想象的，因为你不能用另一个对象去做键。这也是为什么 ES2015 要添加 &lt;code&gt;Map&lt;/code&gt; 类型的缘故，因为它可以做到：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const responseTypes = new Map()
responseTypes.set([&amp;quot;error&amp;quot;, &amp;quot;enoent&amp;quot;], &amp;quot;fatal&amp;quot;)
responseTypes.set([&amp;quot;error&amp;quot;, &amp;quot;busy&amp;quot;], &amp;quot;retry&amp;quot;)

for (let [key, value] of responseTypes) {
  console.log(key, value)
}
// =&amp;gt; [&amp;quot;error&amp;quot;, &amp;quot;enoent&amp;quot;] &amp;quot;fatal&amp;quot;
// =&amp;gt; [&amp;quot;error&amp;quot;, &amp;quot;busy&amp;quot;] &amp;quot;retry&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为 JavaScript 没有元组（尽管有类似原子的符号（Symbol）），所以这个例子不会像 Elixir 那么便利（除非先把作为键名的数组引用保存下来），不过同样的数据结构还是做得到的。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Map&lt;/code&gt; 模块提供了和 &lt;code&gt;Keyword&lt;/code&gt; 模块非常类似的函数，以前它们都是实现自 &lt;code&gt;Dict&lt;/code&gt; 的，但是 again，&lt;code&gt;Dict&lt;/code&gt; 被废弃了哦！&lt;/p&gt;

&lt;p&gt;映射提供了独有的语法来访问和更新键名为原子的值，这一点很有用处：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;iex(1)&amp;gt; map = %{:a =&amp;gt; 1, 2 =&amp;gt; :b}
%{2 =&amp;gt; :b, :a =&amp;gt; 1}
iex(2)&amp;gt; map.a
1
iex(3)&amp;gt; map.c
** (KeyError) key :c not found in: %{2 =&amp;gt; :b, :a =&amp;gt; 1}

iex(3)&amp;gt; %{map | :a =&amp;gt; &amp;quot;1&amp;quot;}
%{2 =&amp;gt; :b, :a =&amp;gt; &amp;quot;1&amp;quot;}
iex(4)&amp;gt; %{map | :c =&amp;gt; 3}
** (KeyError) key :c not found in: %{2 =&amp;gt; :b, :a =&amp;gt; 1}
    (stdlib) :maps.update(:c, 3, %{2 =&amp;gt; :b, :a =&amp;gt; 1})
    (stdlib) erl_eval.erl:255: anonymous fn/2 in :erl_eval.expr/5
    (stdlib) lists.erl:1262: :lists.foldl/3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;乍一看这似乎只是一个语法特性，但在实践中这种语法会带来风格上的变化，&lt;a href=&#34;http://blog.plataformatec.com.br/2014/09/writing-assertive-code-with-elixir/&#34;&gt;这篇文章&lt;/a&gt;描述了 Elixir 程序员是如何使用这种语法来实现更加简洁的“断定式”编码风格的。以后我也会单独撰文来说说这种 &lt;em&gt;assertive code&lt;/em&gt; 风格。&lt;/p&gt;

&lt;p&gt;综合以上可以发现 JavaScript 的 &lt;code&gt;Object&lt;/code&gt; 是综合了关键字列表与映射的特性的，相对而言更加接近关键字列表；过去由于却少 &lt;code&gt;Map&lt;/code&gt; 类型所以也把它当作映射来用，但实际上映射和关键字列表有本质上的差异，适用的场景也非常不同。在学习了 Elixir 之后，反而对 JavaScript 的 &lt;code&gt;Object&lt;/code&gt; 和 &lt;code&gt;Map&lt;/code&gt; 也有了非常明确的理解，真可谓相得益彰啊。&lt;/p&gt;

&lt;p&gt;那么下一篇我要讲函数了，等不及要写点真正有用的东西了😸 ！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JavaScript 程序员眼中的 Elixir：模式匹配</title>
      <link>http://very-geek.github.io/article/elixir-for-javascript-programmer-part-01/</link>
      <pubDate>Wed, 04 May 2016 00:00:00 +0800</pubDate>
      
      <guid>http://very-geek.github.io/article/elixir-for-javascript-programmer-part-01/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;我是一名 JavaScript 程序员，这是写给自己的学习 Elixir 的心得体会。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;想未曾之所想:167f08f7ac85a463feb318cdcdfbed5a&#34;&gt;想未曾之所想&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;面向对象不是唯一的代码设计方法&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;函数式编程语言可以不复杂或者不那么数学化&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;编程的基石不是赋值，if 语句和 loop 循环&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;并发不需要锁、信号量、monitor，及其他种种&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;进程不一定非是昂贵的资源&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;元编程不只是作用于语言本身的&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;能用虽然是根本，但编程也应该有趣才好&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;以上醒言摘自 Programming Elixir 1.2 by Dave Thomas&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;模式匹配-pattern-matching:167f08f7ac85a463feb318cdcdfbed5a&#34;&gt;模式匹配（Pattern Matching）&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;iex(1)&amp;gt; a = 1
1
iex(2)&amp;gt; a + 2
3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;抛开语法细节先不谈，以上两句作为 JavaScript 程序员的我会这样来描述：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;JavaScript：&lt;/em&gt; 把数字 &lt;code&gt;1&lt;/code&gt; 赋值给变量 &lt;code&gt;a&lt;/code&gt;，接着用变量 &lt;code&gt;a&lt;/code&gt; 和数字 &lt;code&gt;2&lt;/code&gt; 相加，求值结果为 &lt;code&gt;3&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这没有什么错，然而在 Elixir 的世界里的表述方法却是完全不同的：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;Elixir：&lt;/em&gt; 首先 &lt;code&gt;=&lt;/code&gt; 并不是赋值符号，它是一种推断，即：如果我能让左边的值等于右边的值，那么此推断为真。所以 &lt;code&gt;=&lt;/code&gt; 被称为：&lt;strong&gt;匹配操作符&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在这里，左边是一个变量（准确的说只是一个名称）而右边是一个整数字面量，所以 Elixir 通过&lt;strong&gt;把变量 &lt;code&gt;a&lt;/code&gt; 绑定给数值 &lt;code&gt;1&lt;/code&gt;&lt;/strong&gt;来让匹配操作为真。你可以说“这就是个赋值嘛！”，别急我们来看看下面的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;iex(1)&amp;gt; a = 1
1
iex(2)&amp;gt; 1 = a
1
iex(3)&amp;gt; 2 = a
** (MatchError) no match of right hand side value: 1
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;同样的代码也可以在 JavaScript 环境里运行一下看看是什么结果。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;请留意第二行代码 &lt;code&gt;1 = a&lt;/code&gt;，这又是一个匹配而且也是真。所以说模式匹配是无关等号两边左值右值的位置的，而赋值操作则不能随意调换。&lt;/p&gt;

&lt;p&gt;但是第三行 &lt;code&gt;2 = a&lt;/code&gt; 就会抛出一个错误了，或许第二行的结果会让你误以为“赋值可以左右值互换”，而这个错误就非常明确的告诉你：Elixir 只会对等号左边的变量绑定值，在右边的时候变量会被它所绑定的值代换。这行代码等价于 &lt;code&gt;2 = 1&lt;/code&gt;，所以才会引起错误。&lt;/p&gt;

&lt;p&gt;再来看一个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;iex(1)&amp;gt; list = [1, 2, 3]
[1, 2, 3]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OK，不难理解。不过从现在开始要习惯这样来表述：&lt;strong&gt;为使匹配为真，把变量 &lt;code&gt;list&lt;/code&gt; 绑定为值 &lt;code&gt;[1, 2, 3]&lt;/code&gt;&lt;/strong&gt;。继续：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;iex(2)&amp;gt; [x, y, z] = list
[1, 2, 3]
iex(3)&amp;gt; x
1
iex(4)&amp;gt; y
2
iex(5)&amp;gt; z
3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;咦？这不就是解构（Destructure）吗？不错，道理一样。但请还是称其为模式匹配，因为模式匹配要比解构更加灵活、强大，且后面我们会看到语法上也还有细微的不同之处。另外上面的代码用我们刚学习的匹配方式来理解也是完全可行的，亲自试一下吧。&lt;/p&gt;

&lt;p&gt;模式匹配的规则是：&lt;strong&gt;模式（左值）和值（右值）仅在拥有相同的结构并且模式中的每一项都能匹配值中对应的项时，模式匹配表达式才为真。&lt;/strong&gt;模式中的字面量值必须完全匹配对应的值，而变量则通过绑定对应值来完成匹配。例如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;iex(1)&amp;gt; list = [1, 2, [3, 4, 5]]
[1, 2, [3, 4, 5]]
iex(2)&amp;gt; [x, y, z] = list
[1, 2, [3, 4, 5]]
iex(3)&amp;gt; x
1
iex(4)&amp;gt; y
2
iex(5)&amp;gt; z
[3, 4, 5]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以及：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;iex(1)&amp;gt; list = [1, 2, 3]
[1, 2, 3]
iex(2)&amp;gt; [x, 2, z] = list
[1, 2, 3]
iex(3)&amp;gt; x
1
iex(4)&amp;gt; z
3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在看到了吧？解构和模式匹配并非完全一样的。话说回来要是模式中的字面量值不能匹配右值的对应项又会怎样呢？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;iex(1)&amp;gt; list = [1, 2, 3]
[1, 2, 3]
iex(2)&amp;gt; [x, 1, z] = list
** (MatchError) no match of right hand side value: [1, 2, 3]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;匹配错误，没啥好说的。&lt;/p&gt;

&lt;h2 id=&#34;忽略不需要的匹配项:167f08f7ac85a463feb318cdcdfbed5a&#34;&gt;忽略不需要的匹配项&lt;/h2&gt;

&lt;p&gt;JavaScript 的解构对于左值的结构是没有约束的，可以完全和右值的结构相等也可以不等，从这个角度来说我反而觉得还是不要用解构与模式匹配对比为好，因为模式匹配的第一个先决条件就是结构相等，其次才是值相等。&lt;/p&gt;

&lt;p&gt;因为模式匹配在左值含有变量的时候会为变量做对应右值的绑定，所以我们才认为它与结构有相似之处。然而模式匹配对结构有约束，所以对不想要匹配的值就得有忽略它的办法。&lt;/p&gt;

&lt;p&gt;Elixir 允许使用 &lt;code&gt;_&lt;/code&gt; 忽略不需要匹配的值，&lt;code&gt;_&lt;/code&gt; 类似变量但是在匹配后会立刻丢弃绑定的值：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;iex(1)&amp;gt; [1, _, _] = [1, 2, 3]
[1, 2, 3]
iex(2)&amp;gt; [name, _] = [&amp;quot;doggy&amp;quot;, 5]
[&amp;quot;doggy&amp;quot;, 5]
iex(3)&amp;gt; name
&amp;quot;doggy&amp;quot;
iex(4)&amp;gt; _
** (CompileError) iex:4: unbound variable _
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你尝试访问 &lt;code&gt;_&lt;/code&gt;，你会看到它总是 &lt;code&gt;unbound variable&lt;/code&gt;（未绑定变量）。&lt;/p&gt;

&lt;h2 id=&#34;不可变的数据绑定:167f08f7ac85a463feb318cdcdfbed5a&#34;&gt;不可变的数据绑定&lt;/h2&gt;

&lt;p&gt;考察下面的例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;iex(1)&amp;gt; foo = 1
1
iex(2)&amp;gt; [1, foo, 3] = [1, 2, 3]
[1, 2, 3]
iex(3)&amp;gt; foo
2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;试想：如果第二行的模式匹配中我希望 &lt;code&gt;foo&lt;/code&gt; 是不变的，也就是以 &lt;code&gt;1&lt;/code&gt; 的值来进行匹配而不是重新绑定为 &lt;code&gt;2&lt;/code&gt; 的话要如何做呢？&lt;/p&gt;

&lt;p&gt;这在 JavaScript 中是“不存在”的问题，除非我硬要这么写：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;{
  var foo = 1
  const [, foo, ] = [1, 2, 3]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果第一句的声明换成 &lt;code&gt;let&lt;/code&gt; 或是 &lt;code&gt;const&lt;/code&gt; 就会抛出异常，具体的原因可以看一下 &lt;a href=&#34;http://babeljs.io/repl/#?evaluate=true&amp;amp;lineWrap=false&amp;amp;presets=es2015&amp;amp;code=%7B%0A%20%20var%20foo%20%3D%201%0A%20%20const%20%5B%2C%20foo%2C%20%5D%20%3D%20%5B1%2C%202%2C%203%5D%0A%7D&#34;&gt;Babel 的转换结果。&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;若是我们要在 Elixir 中强制保留既存的绑定结果，那么就需要在模式匹配的时候使用 &lt;code&gt;^&lt;/code&gt; 操作符，我把它叫做：&lt;strong&gt;图钉操作符（pin operator）&lt;/strong&gt;，顾名思义，就是把前面绑定的结果“摁住”固定下来：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;iex(1)&amp;gt; foo = 1
1
iex(2)&amp;gt; [1, ^foo, 3] = [1, 2, 3]
** (MatchError) no match of right hand side value: [1, 2, 3]

iex(2)&amp;gt; foo
1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;值得注意的是，Elixir 的“长辈” Erlang 是不允许重新绑定变量的，所以图钉操作符是 Elixir 所独有的特性。一开始我曾经疑惑：&lt;em&gt;这一特性岂不是打破了函数式编程语言不可变数据的天性吗？&lt;/em&gt; 不过事实上我是杞人忧天了，Elixir 里的数据依旧是不可变的，这类特性可以视作是“隐秘”的语法糖，为的是让代码写起来更加自然流畅，提高阅读性。&lt;/p&gt;

&lt;p&gt;我想等到专门探讨不可变数据结构的时候再来回顾这些细节，不过&lt;a href=&#34;http://stackoverflow.com/questions/27971357/what-is-the-pin-operator-for-and-are-elixir-variables-mutable&#34;&gt;这一篇 StackOverflow 的问答&lt;/a&gt;已经解释的很清楚了，值得一读。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;第一篇直接跳过了基本的语法、类型及操作符，是因为 Elixir 在这些方面没有什么“意外”的东西，它的语法简洁易懂，实现了所有现代高级语言所共通的部分。而且官方的入门教程已经足够细致，我就没必要浪费文墨了。&lt;/p&gt;

&lt;p&gt;在我看来，对于熟练掌握至少一门高级语言（如我是 JavaScript）的程序员来说，初识 Elixir 的首要任务就是理解和习惯模式匹配，特别是没有函数式编程语言的经验的话这点尤其重要。&lt;/p&gt;

&lt;p&gt;下一篇我打算谈谈集合相关的基础知识，因为对于实战来说，集合是最常用的数据结构了。在使用 JavaScript 语言的过程中，绝大部分时间都是在与函数和各种集合打交道，所以此二者是我关注的重点。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>