+++
categories = ["博文"]
date = "2016-05-04T00:00:00+08:00"
description = ""
isCJKLanguage = true
tags = ["elixir"]
title = "JavaScript 程序员眼中的 Elixir：模式匹配"
+++

> 我是一名 JavaScript 程序员，这是写给自己的学习 Elixir 的心得体会。

## 想未曾之所想

- 面向对象不是唯一的代码设计方法

- 函数式编程语言可以不复杂或者不那么数学化

- 编程的基石不是赋值，if 语句和 loop 循环

- 并发不需要锁、信号量、monitor，及其他种种

- 进程不一定非是昂贵的资源

- 元编程不只是作用于语言本身的

- 能用虽然是根本，但编程也应该有趣才好

> 以上醒言摘自 Programming Elixir 1.2 by Dave Thomas

## 模式匹配（Pattern Matching）

```elixir
iex(1)> a = 1
1
iex(2)> a + 2
3
```

抛开语法细节先不谈，以上两句作为 JavaScript 程序员的我会这样来描述：

> _JavaScript：_ 把数字 `1` 赋值给变量 `a`，接着用变量 `a` 和数字 `2` 相加，求值结果为 `3`

这没有什么错，然而在 Elixir 的世界里的表述方法却是完全不同的：

> _Elixir：_ 首先 `=` 并不是赋值符号，它是一种推断，即：如果我能让左边的值等于右边的值，那么此推断为真。所以 `=` 被称为：**匹配操作符**。

在这里，左边是一个变量（准确的说只是一个名称）而右边是一个整数字面量，所以 Elixir 通过**把变量 `a` 绑定给数值 `1`**来让匹配操作为真。你可以说“这就是个赋值嘛！”，别急我们来看看下面的：

```elixir
iex(1)> a = 1
1
iex(2)> 1 = a
1
iex(3)> 2 = a
** (MatchError) no match of right hand side value: 1
```

> 同样的代码也可以在 JavaScript 环境里运行一下看看是什么结果。

请留意第二行代码 `1 = a`，这又是一个匹配而且也是真。所以说模式匹配是无关等号两边左值右值的位置的，而赋值操作则不能随意调换。

但是第三行 `2 = a` 就会抛出一个错误了，或许第二行的结果会让你误以为“赋值可以左右值互换”，而这个错误就非常明确的告诉你：Elixir 只会对等号左边的变量绑定值，在右边的时候变量会被它所绑定的值代换。这行代码等价于 `2 = 1`，所以才会引起错误。

再来看一个例子：

```elixir
iex(1)> list = [1, 2, 3]
[1, 2, 3]
```

OK，不难理解。不过从现在开始要习惯这样来表述：**为使匹配为真，把变量 `list` 绑定为值 `[1, 2, 3]`**。继续：

```elixir
iex(2)> [x, y, z] = list
[1, 2, 3]
iex(3)> x
1
iex(4)> y
2
iex(5)> z
3
```

咦？这不就是解构（Destructure）吗？不错，道理一样。但请还是称其为模式匹配，因为模式匹配要比解构更加灵活、强大，且后面我们会看到语法上也还有细微的不同之处。另外上面的代码用我们刚学习的匹配方式来理解也是完全可行的，亲自试一下吧。

模式匹配的规则是：**模式（左值）和值（右值）仅在拥有相同的结构并且模式中的每一项都能匹配值中对应的项时，模式匹配表达式才为真。**模式中的字面量值必须完全匹配对应的值，而变量则通过绑定对应值来完成匹配。例如：

```elixir
iex(1)> list = [1, 2, [3, 4, 5]]
[1, 2, [3, 4, 5]]
iex(2)> [x, y, z] = list
[1, 2, [3, 4, 5]]
iex(3)> x
1
iex(4)> y
2
iex(5)> z
[3, 4, 5]
```

以及：

```elixir
iex(1)> list = [1, 2, 3]
[1, 2, 3]
iex(2)> [x, 2, z] = list
[1, 2, 3]
iex(3)> x
1
iex(4)> z
3
```

现在看到了吧？解构和模式匹配并非完全一样的。话说回来要是模式中的字面量值不能匹配右值的对应项又会怎样呢？

```elixir
iex(1)> list = [1, 2, 3]
[1, 2, 3]
iex(2)> [x, 1, z] = list
** (MatchError) no match of right hand side value: [1, 2, 3]
```

匹配错误，没啥好说的。

## 忽略不需要的匹配项

JavaScript 的解构对于左值的结构是没有约束的，可以完全和右值的结构相等也可以不等，从这个角度来说我反而觉得还是不要用解构与模式匹配对比为好，因为模式匹配的第一个先决条件就是结构相等，其次才是值相等。

因为模式匹配在左值含有变量的时候会为变量做对应右值的绑定，所以我们才认为它与结构有相似之处。然而模式匹配对结构有约束，所以对不想要匹配的值就得有忽略它的办法。

Elixir 允许使用 `_` 忽略不需要匹配的值，`_` 类似变量但是在匹配后会立刻丢弃绑定的值：

```elixir
iex(1)> [1, _, _] = [1, 2, 3]
[1, 2, 3]
iex(2)> [name, _] = ["doggy", 5]
["doggy", 5]
iex(3)> name
"doggy"
iex(4)> _
** (CompileError) iex:4: unbound variable _
```

如果你尝试访问 `_`，你会看到它总是 `unbound variable`（未绑定变量）。

## 不可变的数据绑定

考察下面的例子：

```elixir
iex(1)> foo = 1
1
iex(2)> [1, foo, 3] = [1, 2, 3]
[1, 2, 3]
iex(3)> foo
2
```

试想：如果第二行的模式匹配中我希望 `foo` 是不变的，也就是以 `1` 的值来进行匹配而不是重新绑定为 `2` 的话要如何做呢？

这在 JavaScript 中是“不存在”的问题，除非我硬要这么写：

```javascript
{
  var foo = 1
  const [, foo, ] = [1, 2, 3]
}
```

如果第一句的声明换成 `let` 或是 `const` 就会抛出异常，具体的原因可以看一下 [Babel 的转换结果。](http://babeljs.io/repl/#?evaluate=true&lineWrap=false&presets=es2015&code=%7B%0A%20%20var%20foo%20%3D%201%0A%20%20const%20%5B%2C%20foo%2C%20%5D%20%3D%20%5B1%2C%202%2C%203%5D%0A%7D)

若是我们要在 Elixir 中强制保留既存的绑定结果，那么就需要在模式匹配的时候使用 `^` 操作符，我把它叫做：**图钉操作符（pin operator）**，顾名思义，就是把前面绑定的结果“摁住”固定下来：

```elixir
iex(1)> foo = 1
1
iex(2)> [1, ^foo, 3] = [1, 2, 3]
** (MatchError) no match of right hand side value: [1, 2, 3]

iex(2)> foo
1
```

值得注意的是，Elixir 的“长辈” Erlang 是不允许重新绑定变量的，所以图钉操作符是 Elixir 所独有的特性。一开始我曾经疑惑：_这一特性岂不是打破了函数式编程语言不可变数据的天性吗？_ 不过事实上我是杞人忧天了，Elixir 里的数据依旧是不可变的，这类特性可以视作是“隐秘”的语法糖，为的是让代码写起来更加自然流畅，提高阅读性。

我想等到专门探讨不可变数据结构的时候再来回顾这些细节，不过[这一篇 StackOverflow 的问答](http://stackoverflow.com/questions/27971357/what-is-the-pin-operator-for-and-are-elixir-variables-mutable)已经解释的很清楚了，值得一读。

---

第一篇直接跳过了基本的语法、类型及操作符，是因为 Elixir 在这些方面没有什么“意外”的东西，它的语法简洁易懂，实现了所有现代高级语言所共通的部分。而且官方的入门教程已经足够细致，我就没必要浪费文墨了。

在我看来，对于熟练掌握至少一门高级语言（如我是 JavaScript）的程序员来说，初识 Elixir 的首要任务就是理解和习惯模式匹配，特别是没有函数式编程语言的经验的话这点尤其重要。

下一篇我打算谈谈集合相关的基础知识，因为对于实战来说，集合是最常用的数据结构了。在使用 JavaScript 语言的过程中，绝大部分时间都是在与函数和各种集合打交道，所以此二者是我关注的重点。
