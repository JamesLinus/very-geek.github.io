<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>太极客</title>
    <link>http://very-geek.github.io/</link>
    <description>Recent content on 太极客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Thu, 05 May 2016 00:00:00 +0800</lastBuildDate>
    <atom:link href="http://very-geek.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>JavaScript 程序员眼中的 Elixir：集合</title>
      <link>http://very-geek.github.io/article/elixir-for-javascript-programmer-part-02/</link>
      <pubDate>Thu, 05 May 2016 00:00:00 +0800</pubDate>
      
      <guid>http://very-geek.github.io/article/elixir-for-javascript-programmer-part-02/</guid>
      <description>

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;iex(1)&amp;gt; [1, :foo, 3.14, &amp;quot;bar&amp;quot;, {1, 2, 3}]
[1, :foo, 3.14, &amp;quot;bar&amp;quot;, {1, 2, 3}]

iex(2)&amp;gt; {1, :foo, 3.14, &amp;quot;bar&amp;quot;, [1, 2, 3]}
{1, :foo, 3.14, &amp;quot;bar&amp;quot;, [1, 2, 3]}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;请问看过上述代码之后是何感想？我第一次看呢感觉就是：晕～&lt;/p&gt;

&lt;p&gt;那换个问题，上面两种集合哪个接近 JavaScript 里的数组（Array）？从符号上看应该是第一种：列表（List），可实际上最接近的是第二种：元组（Tuple），但是在 Elixir 中我们却不太会用在 JavaScript 中使用数组那样去使用元组。&lt;/p&gt;

&lt;h2 id=&#34;元组-tuple:09efefb5582c071e5bc0e8d88fb3cabd&#34;&gt;元组（Tuple）&lt;/h2&gt;

&lt;p&gt;元组是有序的数值集合，并且它是在内存中连续存储这些数值的，这就意味着通过下标（也是从 0 开始）访问数值以及获得元组的长度这样的操作是很快的。&lt;/p&gt;

&lt;p&gt;典型的 Elixir 程序里一般不太会用元组来表示大量数据集合，有三五个就了不起啦～当需要表示更多的数据的时候会倾向于选择其它的集合类型——JavaScript 里那是没得挑，要么就自己去实现好了。原因？在我看来可能是因为元组并没有实现 &lt;code&gt;Enumerable&lt;/code&gt; 协议的缘故，这个不急我们后面会讲。&lt;/p&gt;

&lt;p&gt;Elixir 用于操作元组的函数并不多，翻翻 API 文档也就十分钟全部看完，不过有几个方法是在 &lt;code&gt;Kernel&lt;/code&gt; 模块里的，要注意别漏了。它们分别是：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Kernel.elem/2&lt;/code&gt;，&lt;code&gt;Kernel.is_tuple/1&lt;/code&gt;，&lt;code&gt;Kernel.put_elem/3&lt;/code&gt;，以及 &lt;code&gt;Kernel.tuple_size/1&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;Elixir 中有一个非常重要的“习俗”：让函数返回元组，且当没有错误的时候，元组的第一个值是原子 &lt;code&gt;:ok&lt;/code&gt;，这个习惯特别像 Node.js 的 error first callback，但在 Elixir 配合模式匹配则更加普遍和强大。下面就是一个常见的例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;iex(1)&amp;gt; File.open(&amp;quot;config.toml&amp;quot;)
{:ok, #PID&amp;lt;0.60.0&amp;gt;}
iex(2)&amp;gt; File.open(&amp;quot;config.yaml&amp;quot;)
{:error, :enoent}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关于这个以后还要深入地说，现在还是把焦点集中在集合上面吧。&lt;/p&gt;

&lt;h2 id=&#34;列表-list:09efefb5582c071e5bc0e8d88fb3cabd&#34;&gt;列表（List）&lt;/h2&gt;

&lt;p&gt;由于写法完全一致所以列表太容易被看作是 JavaScript 数组了，可是相比元组来说列表与数组的差异就更大了。&lt;/p&gt;

&lt;p&gt;首先列表是链表集合而不是线性表集合，列表要么就是空的，要么就是由头（head）和尾（tail）组成：头保存一个值，尾本身又是一个列表。这是一种递归式的结构定义，而它正是大多数 Elixir 程序的核心。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;JavaScript 的数组是线性表集合吗？JavaScript 是动态语言，这意味着数组的存储方式也是可以动态规划的。事实上，不同的引擎对此会有不同的处理方式，因此很难一概而论。大体上我们认为 JavaScript 数组是线性的，因而也会有很多文章教程来探讨在 JavaScript 中创建自己的链表数据结构。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这种结构使得列表利于遍历但不利于随机读取（比如获取列表中第 &lt;em&gt;n&lt;/em&gt; 个元素总是要先扫描前面的 &lt;em&gt;n-1&lt;/em&gt; 个元素）。不过获取列表的头然后提取列表的尾则总是高效的。&lt;/p&gt;

&lt;p&gt;列表有一种特性最值得牢记：对于不可变数据结构来说，想要修改它就意味着要先复制一份新的；然而由于列表是头尾结合的递归结构，要想去掉列表的头就不需要复制列表本身，只需要返回列表尾的指针就可以了。这种特性被广泛应用在列表的遍历与递归操作中。&lt;/p&gt;

&lt;p&gt;列表支持下面的操作符（实际上都是 &lt;code&gt;Kernel&lt;/code&gt; 模块下的函数／宏）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;iex(1)&amp;gt; [1, 2, 3] ++ [4, 5, 6]
[1, 2, 3, 4, 5, 6]
iex(2)&amp;gt; [1, 1, 2, 3, 3, 4] -- [2, 3, 4]
[1, 1, 3]
iex(3)&amp;gt; 1 in [1, 2, 3]
true
iex(4)&amp;gt; 0 in [1, 2, 3]
false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;列表模块里的函数也比元组要多得多，不过在实践中建议优先选择 &lt;code&gt;Enum&lt;/code&gt; 模块下的函数来操作列表。另外 &lt;code&gt;Kernel.hd/1&lt;/code&gt; 与 &lt;code&gt;Kernel.tl/1&lt;/code&gt; 分别用来取列表的头和尾。&lt;/p&gt;

&lt;p&gt;下面是一个有趣的特性叫做字符列表（Char List），目前仅作了解即可。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;iex(1)&amp;gt; [104, 101, 108, 108, 111]
&#39;hello&#39;
iex(2)&amp;gt; &#39;hello&#39; == &amp;quot;hello&amp;quot;
false
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;关键字列表-keyword-list:09efefb5582c071e5bc0e8d88fb3cabd&#34;&gt;关键字列表（Keyword List）&lt;/h2&gt;

&lt;p&gt;虽然名字里还有列表二字，但关键字列表却像 JavaScript 对象字面量那样是键值对形式的数据集合。既然如此为啥还非要算作列表呢？看：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;iex(1)&amp;gt; [name: &amp;quot;nightire&amp;quot;, age: 35] = [{:name, &amp;quot;nightire&amp;quot;}, {:age, 35}]
[name: &amp;quot;nightire&amp;quot;, age: 35]
iex(2)&amp;gt; [name: &amp;quot;nightire&amp;quot;, age: 35] == [{:name, &amp;quot;nightire&amp;quot;}, {:age, 35}]
true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;原来关键字列表就是一个二元元组的列表，每一个元组的第一个元素必须是原子（Atom），第二个元素可以是其它任何值，以此来代表一对关联数据结构。&lt;/p&gt;

&lt;p&gt;关键字列表的重要性源自于它自身的三大特点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;键必须是原子&lt;/li&gt;
&lt;li&gt;键是有序的，遵照定义时的顺序&lt;/li&gt;
&lt;li&gt;键可以给定多次&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面是一些例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;iex(1)&amp;gt; person = [name: &amp;quot;nightire&amp;quot;, age: 35]
[name: &amp;quot;nightire&amp;quot;, age: 35]
iex(2)&amp;gt; person[:name]
&amp;quot;nightire&amp;quot;
iex(3)&amp;gt; person[:age]
35

iex(4)&amp;gt; nightire = person ++ [likes: [&amp;quot;music&amp;quot;, &amp;quot;programming&amp;quot;]]
[name: &amp;quot;nightire&amp;quot;, age: 35, likes: [&amp;quot;music&amp;quot;, &amp;quot;programming&amp;quot;]]
iex(5)&amp;gt; nightire[:likes]
[&amp;quot;music&amp;quot;, &amp;quot;programming&amp;quot;]

iex(6)&amp;gt; younger = [age: 18] ++ nightire
[age: 18, name: &amp;quot;nightire&amp;quot;, age: 35, likes: [&amp;quot;music&amp;quot;, &amp;quot;programming&amp;quot;]]
iex(7)&amp;gt; younger[:age]
18
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关键字列表特别适合用作函数传参或者是用作构造 DSL，比如说：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;query = from p in People,
   where: p.age &amp;gt; 18,
   where: p.weight &amp;lt; 100
  select: p
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以及：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;DB.save record, name: &amp;quot;nightire&amp;quot;, admin: true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个例子同时也告诉我们 Elixir 允许在关键字列表作为函数调用的最后一个参数时省略 &lt;code&gt;[]&lt;/code&gt;。省略环绕标记这件事情有时候会让人晕一下下，特别是要小心下面这种情形：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;iex(1)&amp;gt; [1, 2, foo: &amp;quot;bar&amp;quot;]
[1, 2, {:foo, &amp;quot;bar&amp;quot;}]
iex(2)&amp;gt; {1, 2, foo: &amp;quot;bar&amp;quot;}
{1, 2, [foo: &amp;quot;bar&amp;quot;]}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;除了作为函数参数列表的末尾项之外，作为元组及列表的末尾项也能省略环绕符号，这样的语法特性能省却很多字符但同时也会增加头脑中抽象解释和转换的负担。&lt;/p&gt;

&lt;p&gt;为了操作关键字列表 Elixir 专门提供了 &lt;code&gt;Keyword&lt;/code&gt; 模块，底下的函数也不少。以前关键字列表是实现了 &lt;code&gt;Dict&lt;/code&gt; 模块的，后来 &lt;code&gt;Dict&lt;/code&gt; 被废弃了，以后还是专用 &lt;code&gt;Keyword&lt;/code&gt; 好。&lt;/p&gt;

&lt;h2 id=&#34;映射-map:09efefb5582c071e5bc0e8d88fb3cabd&#34;&gt;映射（Map）&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;我看到一些中文资料把作为数据结构的 &lt;code&gt;Map&lt;/code&gt; 称作图，这是不对的。数据结构中的图应该是 &lt;code&gt;Graph&lt;/code&gt;，而 &lt;code&gt;Map&lt;/code&gt; 虽然有地图的意思但却和数据结构所说的“图”大不相同。&lt;code&gt;Map&lt;/code&gt; 同时也有映射的意思，其实指的就是一一对应的键／值对，在这里的含义非常准确。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;JavaScript 中的对象兼具关键字列表和映射的特性，实际上关键字列表所具备的特性使得它并不适合作为纯数据载体，而映射则特别适合。我猜想这也是为什么 ES2015 会添加 &lt;code&gt;Map&lt;/code&gt; 来替代一部分原属于 &lt;code&gt;Object&lt;/code&gt; 的职责。&lt;/p&gt;

&lt;p&gt;什么意思呢？首先，关键字列表的键只能是原子，相对的 JavaScript 对象的键名只能是字符串（其实还有符号类型，但是属于新数据类型，流传度不高），这就不够灵活了对吧。映射则没有这种限制，任何值都可以做映射中的键和值——包括复合类型；而且还能是表达式。另外如果映射中的键名全部是原子则可以使用关键字列表的语法来定义以提高便利性。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;iex(1)&amp;gt; %{0 =&amp;gt; 0, &amp;quot;one&amp;quot; =&amp;gt; 1, :two =&amp;gt; 2, [1, 2, 3] =&amp;gt; 3}
%{0 =&amp;gt; 0, :two =&amp;gt; 2, [1, 2, 3] =&amp;gt; 3, &amp;quot;one&amp;quot; =&amp;gt; 1}

iex(2)&amp;gt; %{one: 1, two: 2}
%{one: 1, two: 2}
iex(3)&amp;gt; %{one: 1, two: 2} == %{:one =&amp;gt; 1, :two =&amp;gt; 2}
true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其次，映射里的数据是不关心顺序的，而且键也不能重复，如果有重复的键添加进来则会覆盖之前的同名键值对。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;iex(1)&amp;gt; %{one: 1, one: &amp;quot;1&amp;quot;}
%{one: &amp;quot;1&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这一特性使得映射在模式匹配时比关键字列表有用（特别是键名唯一性），看看这些例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;iex(1)&amp;gt; %{} = %{:foo =&amp;gt; &amp;quot;foo&amp;quot;, &amp;quot;bar&amp;quot; =&amp;gt; :bar}
%{:foo =&amp;gt; &amp;quot;foo&amp;quot;, &amp;quot;bar&amp;quot; =&amp;gt; :bar}

iex(2)&amp;gt; %{:foo =&amp;gt; str} = %{:foo =&amp;gt; &amp;quot;foo&amp;quot;, &amp;quot;bar&amp;quot; =&amp;gt; :bar}
%{:foo =&amp;gt; &amp;quot;foo&amp;quot;, &amp;quot;bar&amp;quot; =&amp;gt; :bar}
iex(3)&amp;gt; str
&amp;quot;foo&amp;quot;

iex(4)&amp;gt; %{:baz =&amp;gt; any} = %{:foo =&amp;gt; &amp;quot;foo&amp;quot;, &amp;quot;bar&amp;quot; =&amp;gt; :bar}
** (MatchError) no match of right hand side value: %{:foo =&amp;gt; &amp;quot;foo&amp;quot;, &amp;quot;bar&amp;quot; =&amp;gt; :bar}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;做这种事情的时候是没法依靠关键字列表的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;iex(1)&amp;gt; [foo: str] = [foo: &amp;quot;foo&amp;quot;, bar: &amp;quot;bar&amp;quot;]
** (MatchError) no match of right hand side value: [foo: &amp;quot;foo&amp;quot;, bar: &amp;quot;bar&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 Elixir 中，会经常这样使用映射：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;response_types = %{
  {:error, :enoent} =&amp;gt; :fatal,
  {:error, :busy} =&amp;gt; :retry
}
# %{{:error, :busy} =&amp;gt; :retry, {:error, :enoent} =&amp;gt; :fatal}

response_types[{:error, :busy}]
# :retry
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而在 JavaScript 中如果只考虑对象的话这是不可想象的，因为你不能用另一个对象去做键。这也是为什么 ES2015 要添加 &lt;code&gt;Map&lt;/code&gt; 类型的缘故，因为它可以做到：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const responseTypes = new Map()
responseTypes.set([&amp;quot;error&amp;quot;, &amp;quot;enoent&amp;quot;], &amp;quot;fatal&amp;quot;)
responseTypes.set([&amp;quot;error&amp;quot;, &amp;quot;busy&amp;quot;], &amp;quot;retry&amp;quot;)

for (let [key, value] of responseTypes) {
  console.log(key, value)
}
// =&amp;gt; [&amp;quot;error&amp;quot;, &amp;quot;enoent&amp;quot;] &amp;quot;fatal&amp;quot;
// =&amp;gt; [&amp;quot;error&amp;quot;, &amp;quot;busy&amp;quot;] &amp;quot;retry&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为 JavaScript 没有元组（尽管有类似原子的符号（Symbol）），所以这个例子不会像 Elixir 那么便利（除非先把作为键名的数组引用保存下来），不过同样的数据结构还是做得到的。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Map&lt;/code&gt; 模块提供了和 &lt;code&gt;Keyword&lt;/code&gt; 模块非常类似的函数，以前它们都是实现自 &lt;code&gt;Dict&lt;/code&gt; 的，但是 again，&lt;code&gt;Dict&lt;/code&gt; 被废弃了哦！&lt;/p&gt;

&lt;p&gt;映射提供了独有的语法来访问和更新键名为原子的值，这一点很有用处：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;iex(1)&amp;gt; map = %{:a =&amp;gt; 1, 2 =&amp;gt; :b}
%{2 =&amp;gt; :b, :a =&amp;gt; 1}
iex(2)&amp;gt; map.a
1
iex(3)&amp;gt; map.c
** (KeyError) key :c not found in: %{2 =&amp;gt; :b, :a =&amp;gt; 1}

iex(3)&amp;gt; %{map | :a =&amp;gt; &amp;quot;1&amp;quot;}
%{2 =&amp;gt; :b, :a =&amp;gt; &amp;quot;1&amp;quot;}
iex(4)&amp;gt; %{map | :c =&amp;gt; 3}
** (KeyError) key :c not found in: %{2 =&amp;gt; :b, :a =&amp;gt; 1}
    (stdlib) :maps.update(:c, 3, %{2 =&amp;gt; :b, :a =&amp;gt; 1})
    (stdlib) erl_eval.erl:255: anonymous fn/2 in :erl_eval.expr/5
    (stdlib) lists.erl:1262: :lists.foldl/3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;乍一看这似乎只是一个语法特性，但在实践中这种语法会带来风格上的变化，&lt;a href=&#34;http://blog.plataformatec.com.br/2014/09/writing-assertive-code-with-elixir/&#34;&gt;这篇文章&lt;/a&gt;描述了 Elixir 程序员是如何使用这种语法来实现更加简洁的“断定式”编码风格的。以后我也会单独撰文来说说这种 &lt;em&gt;assertive code&lt;/em&gt; 风格。&lt;/p&gt;

&lt;p&gt;综合以上可以发现 JavaScript 的 &lt;code&gt;Object&lt;/code&gt; 是综合了关键字列表与映射的特性的，相对而言更加接近关键字列表；过去由于却少 &lt;code&gt;Map&lt;/code&gt; 类型所以也把它当作映射来用，但实际上映射和关键字列表有本质上的差异，适用的场景也非常不同。在学习了 Elixir 之后，反而对 JavaScript 的 &lt;code&gt;Object&lt;/code&gt; 和 &lt;code&gt;Map&lt;/code&gt; 也有了非常明确的理解，真可谓相得益彰啊。&lt;/p&gt;

&lt;p&gt;那么下一篇我要讲函数了，等不及要写点真正有用的东西了😸 ！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JavaScript 程序员眼中的 Elixir：模式匹配</title>
      <link>http://very-geek.github.io/article/elixir-for-javascript-programmer-part-01/</link>
      <pubDate>Wed, 04 May 2016 00:00:00 +0800</pubDate>
      
      <guid>http://very-geek.github.io/article/elixir-for-javascript-programmer-part-01/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;我是一名 JavaScript 程序员，这是写给自己的学习 Elixir 的心得体会。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;想未曾之所想:167f08f7ac85a463feb318cdcdfbed5a&#34;&gt;想未曾之所想&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;面向对象不是唯一的代码设计方法&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;函数式编程语言可以不复杂或者不那么数学化&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;编程的基石不是赋值，if 语句和 loop 循环&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;并发不需要锁、信号量、monitor，及其他种种&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;进程不一定非是昂贵的资源&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;元编程不只是作用于语言本身的&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;能用虽然是根本，但编程也应该有趣才好&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;以上醒言摘自 Programming Elixir 1.2 by Dave Thomas&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;模式匹配-pattern-matching:167f08f7ac85a463feb318cdcdfbed5a&#34;&gt;模式匹配（Pattern Matching）&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;iex(1)&amp;gt; a = 1
1
iex(2)&amp;gt; a + 2
3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;抛开语法细节先不谈，以上两句作为 JavaScript 程序员的我会这样来描述：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;JavaScript：&lt;/em&gt; 把数字 &lt;code&gt;1&lt;/code&gt; 赋值给变量 &lt;code&gt;a&lt;/code&gt;，接着用变量 &lt;code&gt;a&lt;/code&gt; 和数字 &lt;code&gt;2&lt;/code&gt; 相加，求值结果为 &lt;code&gt;3&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这没有什么错，然而在 Elixir 的世界里的表述方法却是完全不同的：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;Elixir：&lt;/em&gt; 首先 &lt;code&gt;=&lt;/code&gt; 并不是赋值符号，它是一种推断，即：如果我能让左边的值等于右边的值，那么此推断为真。所以 &lt;code&gt;=&lt;/code&gt; 被称为：&lt;strong&gt;匹配操作符&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在这里，左边是一个变量（准确的说只是一个名称）而右边是一个整数字面量，所以 Elixir 通过&lt;strong&gt;把变量 &lt;code&gt;a&lt;/code&gt; 绑定给数值 &lt;code&gt;1&lt;/code&gt;&lt;/strong&gt;来让匹配操作为真。你可以说“这就是个赋值嘛！”，别急我们来看看下面的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;iex(1)&amp;gt; a = 1
1
iex(2)&amp;gt; 1 = a
1
iex(3)&amp;gt; 2 = a
** (MatchError) no match of right hand side value: 1
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;同样的代码也可以在 JavaScript 环境里运行一下看看是什么结果。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;请留意第二行代码 &lt;code&gt;1 = a&lt;/code&gt;，这又是一个匹配而且也是真。所以说模式匹配是无关等号两边左值右值的位置的，而赋值操作则不能随意调换。&lt;/p&gt;

&lt;p&gt;但是第三行 &lt;code&gt;2 = a&lt;/code&gt; 就会抛出一个错误了，或许第二行的结果会让你误以为“赋值可以左右值互换”，而这个错误就非常明确的告诉你：Elixir 只会对等号左边的变量绑定值，在右边的时候变量会被它所绑定的值代换。这行代码等价于 &lt;code&gt;2 = 1&lt;/code&gt;，所以才会引起错误。&lt;/p&gt;

&lt;p&gt;再来看一个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;iex(1)&amp;gt; list = [1, 2, 3]
[1, 2, 3]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OK，不难理解。不过从现在开始要习惯这样来表述：&lt;strong&gt;为使匹配为真，把变量 &lt;code&gt;list&lt;/code&gt; 绑定为值 &lt;code&gt;[1, 2, 3]&lt;/code&gt;&lt;/strong&gt;。继续：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;iex(2)&amp;gt; [x, y, z] = list
[1, 2, 3]
iex(3)&amp;gt; x
1
iex(4)&amp;gt; y
2
iex(5)&amp;gt; z
3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;咦？这不就是解构（Destructure）吗？不错，道理一样。但请还是称其为模式匹配，因为模式匹配要比解构更加灵活、强大，且后面我们会看到语法上也还有细微的不同之处。另外上面的代码用我们刚学习的匹配方式来理解也是完全可行的，亲自试一下吧。&lt;/p&gt;

&lt;p&gt;模式匹配的规则是：&lt;strong&gt;模式（左值）和值（右值）仅在拥有相同的结构并且模式中的每一项都能匹配值中对应的项时，模式匹配表达式才为真。&lt;/strong&gt;模式中的字面量值必须完全匹配对应的值，而变量则通过绑定对应值来完成匹配。例如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;iex(1)&amp;gt; list = [1, 2, [3, 4, 5]]
[1, 2, [3, 4, 5]]
iex(2)&amp;gt; [x, y, z] = list
[1, 2, [3, 4, 5]]
iex(3)&amp;gt; x
1
iex(4)&amp;gt; y
2
iex(5)&amp;gt; z
[3, 4, 5]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以及：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;iex(1)&amp;gt; list = [1, 2, 3]
[1, 2, 3]
iex(2)&amp;gt; [x, 2, z] = list
[1, 2, 3]
iex(3)&amp;gt; x
1
iex(4)&amp;gt; z
3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在看到了吧？解构和模式匹配并非完全一样的。话说回来要是模式中的字面量值不能匹配右值的对应项又会怎样呢？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;iex(1)&amp;gt; list = [1, 2, 3]
[1, 2, 3]
iex(2)&amp;gt; [x, 1, z] = list
** (MatchError) no match of right hand side value: [1, 2, 3]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;匹配错误，没啥好说的。&lt;/p&gt;

&lt;h2 id=&#34;忽略不需要的匹配项:167f08f7ac85a463feb318cdcdfbed5a&#34;&gt;忽略不需要的匹配项&lt;/h2&gt;

&lt;p&gt;JavaScript 的解构对于左值的结构是没有约束的，可以完全和右值的结构相等也可以不等，从这个角度来说我反而觉得还是不要用解构与模式匹配对比为好，因为模式匹配的第一个先决条件就是结构相等，其次才是值相等。&lt;/p&gt;

&lt;p&gt;因为模式匹配在左值含有变量的时候会为变量做对应右值的绑定，所以我们才认为它与结构有相似之处。然而模式匹配对结构有约束，所以对不想要匹配的值就得有忽略它的办法。&lt;/p&gt;

&lt;p&gt;Elixir 允许使用 &lt;code&gt;_&lt;/code&gt; 忽略不需要匹配的值，&lt;code&gt;_&lt;/code&gt; 类似变量但是在匹配后会立刻丢弃绑定的值：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;iex(1)&amp;gt; [1, _, _] = [1, 2, 3]
[1, 2, 3]
iex(2)&amp;gt; [name, _] = [&amp;quot;doggy&amp;quot;, 5]
[&amp;quot;doggy&amp;quot;, 5]
iex(3)&amp;gt; name
&amp;quot;doggy&amp;quot;
iex(4)&amp;gt; _
** (CompileError) iex:4: unbound variable _
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你尝试访问 &lt;code&gt;_&lt;/code&gt;，你会看到它总是 &lt;code&gt;unbound variable&lt;/code&gt;（未绑定变量）。&lt;/p&gt;

&lt;h2 id=&#34;不可变的数据绑定:167f08f7ac85a463feb318cdcdfbed5a&#34;&gt;不可变的数据绑定&lt;/h2&gt;

&lt;p&gt;考察下面的例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;iex(1)&amp;gt; foo = 1
1
iex(2)&amp;gt; [1, foo, 3] = [1, 2, 3]
[1, 2, 3]
iex(3)&amp;gt; foo
2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;试想：如果第二行的模式匹配中我希望 &lt;code&gt;foo&lt;/code&gt; 是不变的，也就是以 &lt;code&gt;1&lt;/code&gt; 的值来进行匹配而不是重新绑定为 &lt;code&gt;2&lt;/code&gt; 的话要如何做呢？&lt;/p&gt;

&lt;p&gt;这在 JavaScript 中是“不存在”的问题，除非我硬要这么写：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;{
  var foo = 1
  const [, foo, ] = [1, 2, 3]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果第一句的声明换成 &lt;code&gt;let&lt;/code&gt; 或是 &lt;code&gt;const&lt;/code&gt; 就会抛出异常，具体的原因可以看一下 &lt;a href=&#34;http://babeljs.io/repl/#?evaluate=true&amp;amp;lineWrap=false&amp;amp;presets=es2015&amp;amp;code=%7B%0A%20%20var%20foo%20%3D%201%0A%20%20const%20%5B%2C%20foo%2C%20%5D%20%3D%20%5B1%2C%202%2C%203%5D%0A%7D&#34;&gt;Babel 的转换结果。&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;若是我们要在 Elixir 中强制保留既存的绑定结果，那么就需要在模式匹配的时候使用 &lt;code&gt;^&lt;/code&gt; 操作符，我把它叫做：&lt;strong&gt;图钉操作符（pin operator）&lt;/strong&gt;，顾名思义，就是把前面绑定的结果“摁住”固定下来：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;iex(1)&amp;gt; foo = 1
1
iex(2)&amp;gt; [1, ^foo, 3] = [1, 2, 3]
** (MatchError) no match of right hand side value: [1, 2, 3]

iex(2)&amp;gt; foo
1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;值得注意的是，Elixir 的“长辈” Erlang 是不允许重新绑定变量的，所以图钉操作符是 Elixir 所独有的特性。一开始我曾经疑惑：&lt;em&gt;这一特性岂不是打破了函数式编程语言不可变数据的天性吗？&lt;/em&gt; 不过事实上我是杞人忧天了，Elixir 里的数据依旧是不可变的，这类特性可以视作是“隐秘”的语法糖，为的是让代码写起来更加自然流畅，提高阅读性。&lt;/p&gt;

&lt;p&gt;我想等到专门探讨不可变数据结构的时候再来回顾这些细节，不过&lt;a href=&#34;http://stackoverflow.com/questions/27971357/what-is-the-pin-operator-for-and-are-elixir-variables-mutable&#34;&gt;这一篇 StackOverflow 的问答&lt;/a&gt;已经解释的很清楚了，值得一读。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;第一篇直接跳过了基本的语法、类型及操作符，是因为 Elixir 在这些方面没有什么“意外”的东西，它的语法简洁易懂，实现了所有现代高级语言所共通的部分。而且官方的入门教程已经足够细致，我就没必要浪费文墨了。&lt;/p&gt;

&lt;p&gt;在我看来，对于熟练掌握至少一门高级语言（如我是 JavaScript）的程序员来说，初识 Elixir 的首要任务就是理解和习惯模式匹配，特别是没有函数式编程语言的经验的话这点尤其重要。&lt;/p&gt;

&lt;p&gt;下一篇我打算谈谈集合相关的基础知识，因为对于实战来说，集合是最常用的数据结构了。在使用 JavaScript 语言的过程中，绝大部分时间都是在与函数和各种集合打交道，所以此二者是我关注的重点。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>EmberConf 2016 开场演讲阅后感</title>
      <link>http://very-geek.github.io/insight/emberconf-2016-opening-keynote-by-yehuda-katz-and-tom-dale/</link>
      <pubDate>Sat, 30 Apr 2016 00:00:00 +0800</pubDate>
      
      <guid>http://very-geek.github.io/insight/emberconf-2016-opening-keynote-by-yehuda-katz-and-tom-dale/</guid>
      <description>

&lt;p&gt;我自己是 Ember 的忠实拥趸，即便目前的产品没有用 Ember 技术栈也会关注 Ember 生态圈里的最新动态。这个视频来自于 EmberConf 2016 的开场演讲，主讲者是 Yehuda Katz 和 Tom Dale 这俩位老搭档。&lt;/p&gt;

&lt;p&gt;视频的前半段是回顾 2015，&lt;em&gt;25:00&lt;/em&gt; 往后开始讲对未来的展望了，我喜欢看这类型的内容。虽然说没人能够准确的预见未来，但是通过聆听这些站在行业尖端的人物们的分析和见解依然可以勾勒出未来的大致形状。技术工作者也是需要投资的，投资的不是金钱与物质而是对技术发展方向的预判从而合理分配学习和研究的精力。&lt;/p&gt;

&lt;h2 id=&#34;web-apps-和-mobile-apps:5f7b2199d9213c08f11f7b660bd516d0&#34;&gt;Web Apps 和 Mobile Apps&lt;/h2&gt;

&lt;p&gt;两位谈到了一个有趣的现状：你拿着手机正在浏览推特，看见有人分享了放在 Instagram上的有趣的图片。你点进去看看，进入了 Instaram 的网站，然后就提示你安装 Instagram App。好吧，你点击安装就跳转到了 App Store／Google Play 然后安装，网速不错的话这个时间相对也不算太长。终于装好了，你觉得可以看了吧？结果点开一看——找不到刚才人家分享的那个图片了……&lt;/p&gt;

&lt;p&gt;这就是原生应用的尴尬之处。&lt;/p&gt;

&lt;p&gt;尽管人们总是在强调原生应用的功能优势、性能优势、体验优势等等，但无法否认互联网的根基在于 Web，无论原生应用怎么折腾，人们获取信息的最主要渠道依然是 Web。Web 应用的劣势的确是客观存在的，但却是能通过技术发展逐个解决的。所以用发展性的眼光来看 Web 应用的前景反而是最光明的。&lt;/p&gt;

&lt;p&gt;更重要的是过去两年人们不停地无情“批判”的 Web 应用的缺陷在现今其实都有了相应的技术解决方案，举例来说：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;Web 应用&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;原生应用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;（几乎）迅速开启&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;迅速开启&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;（大部分）需要在线&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;离线可用&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;（一些）设备特性访问受限&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;丰富的设备特性支持&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;（一些）动效性能底下&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;快速，动效好&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;这样的列表还可以扩展下去，但无非就是两个层面：参与性（粘性）和体验性。在这两方面现在的 Web 应用技术已经可以做到接近甚至媲美原生应用技术的程度了。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Web 应用“落地”&lt;/strong&gt;：Service Worker／Add to Home Screen&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;消息推送&lt;/strong&gt;：Service Worker&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;快速启动&lt;/strong&gt;：Service Worker／App Cache&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;离线应用&lt;/strong&gt;：Service Worder／App Cache／IndexedDB&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;App Cache 在 FireFox 44 时已经处于 deprecated 状态并且在未来将会被移除以便为 Service Worker 让道，而 Google Chrome 也附和了这一提议。因此 Service Worker 是离线应用的未来，而且它能做到的事情更多。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我非常惊讶且欣喜的看到 &lt;em&gt;Service Worker&lt;/em&gt; 的强大和普适性，它马上成为我的研究列表上排名前三的技术点之一。&lt;/p&gt;

&lt;p&gt;同时我也想到自己在最近一段时间也曾分出一些精力去尝试了 React Native（或类似的）技术，不能否认它们会让你感觉很惊艳，但我也问过自己：&lt;strong&gt;为什么我们要用 Web 的技术去追求创造原生应用呢？&lt;/strong&gt;或者反过来说为什么我们不继续大力发展 Web 技术让它在保持自身特色的同时进化到至少和原生应用平起平坐呢？&lt;/p&gt;

&lt;p&gt;从这个角度出发你甚至会悚然发现：React Native 甚至是有点“短视”和“杀鸡取卵”的技术方向，至少在我看来它的生命周期不会太长，刚好是在这个“青黄不接”的时代的中间产物。&lt;/p&gt;

&lt;p&gt;还有一些观点揪着 Web 框架的体积不放，说你们太大了打开都要花好久时间，怎么适合做应用呢？两位举了一个例子：原生的 Instagram iOS 应用有多大？&lt;strong&gt;39.1MB&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当你下载 Instagram 的时候怎么就不觉得大了呢？这事儿其实要从俩方面来讲。一方面的确是有太多的 Web App 仅仅只是把功能做出来了而已，很多方面的优化实在是不到位，所以回回打开回回慢自然无法给人带来好的观感印象；但另外一方面 Web App 的确是能够做到极速的，不仅仅是首次加载而已。可是 Web 的技术栈处在一个迅速发展不断变化的阶段，即便是专业从业者也只有很少的一部分可以完全拿得下、吃得住。&lt;/p&gt;

&lt;p&gt;总之，Web Apps 的能力和潜力是够的，并且随着技术的发展它只会越来越好，更不要说它有一些先天优势是原生应用也好桌面应用也罢永远也无法媲美的，现阶段我们需要的不是选择去做哪个方向的指导性建议，而是一个足够好的技术栈和生态社区去带领我们发展和超越。Ember 是这个答案吗？我不能给出答案（不是没有答案，而是不能给出）。&lt;/p&gt;

&lt;h2 id=&#34;平衡-功能-和-体积:5f7b2199d9213c08f11f7b660bd516d0&#34;&gt;平衡“功能”和“体积”&lt;/h2&gt;

&lt;p&gt;体积在一定意义上决定了功能的丰富性，这很好理解，而另一方面体积又对加载与启动速度有反作用。我们如何在不牺牲任何功能的前提下，约束应用的体积，或者说加速应用的加载与启动呢？&lt;/p&gt;

&lt;p&gt;接下来的部分，Yehuda 和 Tom 讲述了 Ember 的计划，这个计划由六个技术点组成，依照应用程序的首次启动和后续启动分成两部分各负其责，它们分别是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;首次启动：&lt;/strong&gt; &lt;em&gt;FastBoot&lt;/em&gt;, &lt;em&gt;Project Svelte&lt;/em&gt;, &lt;em&gt;Engines&lt;/em&gt;, &lt;em&gt;String Loading&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;后续启动：&lt;/strong&gt; &lt;em&gt;Service Worker&lt;/em&gt;, &lt;em&gt;String Loading&lt;/em&gt;, &lt;em&gt;App Cache&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;fastboot:5f7b2199d9213c08f11f7b660bd516d0&#34;&gt;FastBoot&lt;/h3&gt;

&lt;p&gt;FastBoot 是一个 Big Thing，早在一年前的 EmberConf 2015 就已经宣布启动了。其实FastBoot 就是服务端渲染技术，但它不是一个单一的技术而是许多技术的综合解决方案。最近我一直在做以 React 为中心的服务端渲染，其中所涉及到的技术难点还是比较了解的。不要脸的说，我对自己做出的成果还算满意吧，但是 FastBoot 所要应对的技术范围和应用场景要大得多——这可不是为了满足某个应用或某个团队的解决方案；更重要的是FastBoot 还会在社区的推动下不断的发展下去，比起个人项目，其能量和影响是不可同日而语的。&lt;/p&gt;

&lt;h3 id=&#34;project-svelte:5f7b2199d9213c08f11f7b660bd516d0&#34;&gt;Project Svelte&lt;/h3&gt;

&lt;p&gt;这里的 Project 主要是指 Ember 自身。自v2.4 开始 Ember 开启了 LTS 的版本计划，也正是从这个版本开始，Ember 将会彻底移除过去一直在 Deprecated 的部分代码，这部分代码的体积是相当可观的。&lt;/p&gt;

&lt;p&gt;另外，Ember 的所有代码都将以 ES2015 Modules 的格式进行分发，以充分利用 Tree Shaking 技术（没错，就是 Webpack 2 也会有的 Tree Shaking）。还有一些不再需要的模块也将会被彻底清理掉。&lt;/p&gt;

&lt;h3 id=&#34;engines:5f7b2199d9213c08f11f7b660bd516d0&#34;&gt;Engines&lt;/h3&gt;

&lt;p&gt;大体上可以将 Engines 视作按需加载的处理技术，应用代码将被很容易的分成若干个包，而用户只需要加载他们正在使用的部分的对应代码。&lt;/p&gt;

&lt;h3 id=&#34;string-loading:5f7b2199d9213c08f11f7b660bd516d0&#34;&gt;String Loading&lt;/h3&gt;

&lt;p&gt;这是一个很有意思的举措，JavaScript 模块在分发时会以字符串的方式输出，于是只有真正被用到的模块代码才会产生解析求值的消耗。我不知道这对提升性能有多大的助益，回头有空去研究下里面的细节。&lt;/p&gt;

&lt;h3 id=&#34;service-worker:5f7b2199d9213c08f11f7b660bd516d0&#34;&gt;Service Worker&lt;/h3&gt;

&lt;p&gt;它的作用主要体现在三方面：1）离线应用；2）精细化控制网络通信／数据传输；3）主动性资源预加载。&lt;/p&gt;

&lt;h3 id=&#34;app-cache:5f7b2199d9213c08f11f7b660bd516d0&#34;&gt;App Cache&lt;/h3&gt;

&lt;p&gt;应用级别的缓存可以使得首次加载之后再也不需要下载静态资源，另外也可以做到应用程序自动升级。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;我相信上面谈到的东西都不算是什么新鲜事物或是黑魔法了，只是它们在实践中还是甚少被用到。为什么？缺少领头羊，缺少真正可靠的整合型解决方案。Ember 会是答案吗？Well，我不能回答你啊。&lt;/p&gt;

&lt;p&gt;接下来又回到了渲染性能的老话题了，在 Ember 的世界里也就是 Glimmer 了。Yehuda 展示了 Glimmer 2 的最新进展，结果当然是喜人的，渲染性能超过 React 2~3 倍（上千个组件不断 Update）。不过老实说我对这样的性能比较早就免疫了，现实中的开发渲染的性能瓶颈极少在框架的渲染引擎这里（除了做测试的极端例子之外）。换句话说，极端测试里能达到 60fps 并不能代表你做真实的项目就轻易能达到这个指标——你永远也不能指望一个框架帮你做到所有的事情。我们只能说 Glimmer 2 为我们打下了一个很好的基础，剩下的事还要靠我们自己。&lt;/p&gt;

&lt;h2 id=&#34;总结:5f7b2199d9213c08f11f7b660bd516d0&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;不管怎么说，就像 Tom 最后的总结一样：&lt;em&gt;The way we build web apps is changing&lt;/em&gt; 。而 Ember 的口号也正式变成了 &lt;em&gt;A SDK of Web&lt;/em&gt; ，这意味着我们已经走过了“如何去构建现代化 web 应用”的时代，正朝着“如何去构建更好的现代化 web 应用”进发。作为一个框架，Ember 已经交出了自己的答卷（打多少分是个人的事情，我给 90 分，剩下十分嘛……😸）；作为一个 SDK，Ember 正在路上，至少我是很期待着。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>